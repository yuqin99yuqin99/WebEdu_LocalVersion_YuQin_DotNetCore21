<!--
wwwroot folder: The Web Root folder for the app containing the app's public static assets, including appsettings.json and environmental app settings files for configuration settings and sample weather data (sample-data/weather.json).
-->
<!--
When any page of the app is initially requested, this page is rendered and returned in the response.
The page specifies where the root App component is rendered. The component is rendered at the location of the div DOM element with an id of app (<div id="app">Loading...</div>).
-->
<!--
 static files
For the location of <head> content where static file links are placed, see ASP.NET Core Blazor project structure. Static asset links can also be supplied using <HeadContent> components in individual Razor components.
    By default, publishing the app places the app's static assets, including Blazor framework files (_framework folder assets), at the root path (/) in published output. The <StaticWebAssetBasePath> property specified in the project file (.csproj) sets the base path to a non-root path:

XML

Copy
<PropertyGroup>
  <StaticWebAssetBasePath>{PATH}</StaticWebAssetBasePath>
</PropertyGroup>
In the preceding example, the {PATH} placeholder is the path.

Without setting the <StaticWebAssetBasePath> property, a standalone app is published at /BlazorStandaloneSample/bin/Release/{TFM}/publish/wwwroot/.

In the preceding example, the {TFM} placeholder is the Target Framework Moniker (TFM) (for example, net6.0).

If the <StaticWebAssetBasePath> property in a standalone Blazor WebAssembly app sets the published static asset path to app1, the root path to the app in published output is /app1.

In the standalone Blazor WebAssembly app's project file (.csproj):

XML

Copy
<PropertyGroup>
  <StaticWebAssetBasePath>app1</StaticWebAssetBasePath>
</PropertyGroup>
In published output, the path to the standalone Blazor WebAssembly app is /BlazorStandaloneSample/bin/Release/{TFM}/publish/wwwroot/app1/.

In the preceding example, the {TFM} placeholder is the Target Framework Moniker (TFM) (for example, net6.0).
-->
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Blazor_WebAssembly_PWA_YuQin</title>
    <base href="/Blazor_WebAssembly_PWA_YuQin/" />
    <link rel="stylesheet" href="css/bootstrap/bootstrap.min.css" />
    <link rel="stylesheet" href="css/app.css" />
    <link rel="icon" type="image/png" href="favicon.png" />
    <link href="Blazor_WebAssembly_PWA_YuQin.styles.css" rel="stylesheet" />
    <link href="manifest.webmanifest" rel="manifest" />
    <link rel="apple-touch-icon" sizes="512x512" href="icon-512.png" />
    <link rel="apple-touch-icon" sizes="192x192" href="icon-192.png" />


    <!-- Start Single Page Apps for GitHub Pages -->
    <script type="text/javascript">
        // Single Page Apps for GitHub Pages
        // https://github.com/rafrex/spa-github-pages
        // Copyright (c) 2016 Rafael Pedicini, licensed under the MIT License
        // ----------------------------------------------------------------------
        // This script checks to see if a redirect is present in the query string
        // and converts it back into the correct url and adds it to the
        // browser's history using window.history.replaceState(...),
        // which won't cause the browser to attempt to load the new url.
        // When the single page app is loaded further down in this file,
        // the correct url will be waiting in the browser's history for
        // the single page app to route accordingly.
        (function (l) {
            if (l.search) {
                var q = {};
                l.search.slice(1).split('&').forEach(function (v) {
                    var a = v.split('=');
                    q[a[0]] = a.slice(1).join('=').replace(/~and~/g, '&');
                });
                if (q.p !== undefined) {
                    window.history.replaceState(null, null,
                        l.pathname.slice(0, -1) + (q.p || '') +
                        (q.q ? ('?' + q.q) : '') +
                        l.hash
                    );
                }
            }
        }(window.location))
    </script>
    <!-- End Single Page Apps for GitHub Pages -->
</head>

<body>
    <div>
        ‰∏ãËø∞ÊòØ.html/.svg/.x3d/.css/.jsÊñá‰ª∂ÁöÑËßÜÂõæVÔºåÂ∞Ü‰∏çÊñ≠Â∞ùËØïÊîπÂÜôÊàê‰∏∫.html/.svg/.x3d/.css/.js/.razor.csÊñá‰ª∂ÁöÑËßÜÂõæV„ÄÇ
    </div>
    <div>
        <iframe src="https://jbhuang99.github.io/WebEdu_LocalVersion_YuQin_DotNetCore2.1/ASPDotNet_MVC_YuQin/wwwroot/webCourse/common/iframeInitial.html?iWidth=1024&iHeight=738" width="100%" height="768" align="middle"></iframe>
    </div>
    <!--ÊâøÊé•Blazor WebAssemblyÁöÑ.dllÊñá‰ª∂ÂÖ•Âè£Êñá‰ª∂program.cs‰∏≠ÁöÑÂ¶Ç‰∏ã‰ª£Á†ÅÔºöbuilder.RootComponents.Add<App>("#app")-->
    <div id="app">
        <svg class="loading-progress">
            <circle r="40%" cx="50%" cy="50%" />
            <circle r="40%" cx="50%" cy="50%" />
        </svg>
        <div class="loading-progress-text"></div>
    </div>

    <div id="blazor-error-ui">
        An unhandled error has occurred.
        <a href="" class="reload">Reload</a>
        <a class="dismiss">üóô</a>
    </div>
    <script src="decode.js"></script>
    <script src="_content/Microsoft.AspNetCore.Components.WebAssembly.Authentication/AuthenticationService.js"></script>
    <!--Âä†ËΩΩBlazor WebAssemblyÁöÑ.dllÊñá‰ª∂„ÄÇ‰∏ÄÊó¶Blazor WebAssembly‰ª£Á†ÅÂä†ËΩΩÂÆåÊàêÔºåÂ∞±‰ºöËøêË°åÂÖ•Âè£Êñá‰ª∂program.cs‰∏≠ÁöÑÂ¶Ç‰∏ã‰ª£Á†ÅÔºöbuilder.RootComponents.Add<App>("#app");ÂëäËØâRendererÔºåAppÁ±ªÁªÑ‰ª∂ÊòØRenderTreeÁöÑÊ†πÁªÑ‰ª∂ÔºåÂπ∂Â∞ÜÂÆÉÁöÑDOMÂä†ËΩΩÂà∞ÊµèËßàÂô®DOM‰∏≠ÁöÑAppÂÖÉÁ¥†ÔºàId‰∏∫AppÁöÑÂÖÉÁ¥†Ôºâ-->
    <script src="_framework/blazor.webassembly.js"></script>
    <!--Âä†ËΩΩPWAÁõ∏ÂÖ≥ÁöÑÁéØÂ¢É-->
    <script>navigator.serviceWorker.register('service-worker.js');</script>
    <script>
        Blazor.start({
            loadBootResource: function (type, name, defaultUri, integrity) {
                // For framework resources, use the precompressed .br files for faster downloads
                // This is needed only because GitHub pages doesn't natively support Brotli (or even gzip for .dll files)
                if (type !== 'dotnetjs' && location.hostname !== 'localhost') {
                    return (async function () {
                        const response = await fetch(defaultUri + '.br', { cache: 'no-cache' });
                        if (!response.ok) {
                            throw new Error(response.statusText);
                        }
                        const originalResponseBuffer = await response.arrayBuffer();
                        const originalResponseArray = new Int8Array(originalResponseBuffer);
                        const decompressedResponseArray = BrotliDecode(originalResponseArray);
                        const contentType = type === 'dotnetwasm' ? 'application/wasm' : 'application/octet-stream';
                        return new Response(decompressedResponseArray, { headers: { 'content-type': contentType } });
                    })();
                }
            }
        });
    </script>
</body>

</html>
